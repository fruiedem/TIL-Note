
메소드 개념
기본 제공 메서드
	mutable function, immutable function (immutable programming 권장)
	immutable programming 을 권장하는 이유(해당 강의에서 설명 X)
	spread operator
		메모리 공간 차이


**메서드 개념**
클래스에 귀속되는 함수



**mutable function**
리턴값 정리
> 원소 추가할 때 리턴값은 : 배열의 길이
> 원소 삭제할 때 리턴값은 : 삭제된 원소의 값
1. push
> 배열 마지막 원소로 추가
> 배열을 직접 변경
> 리턴값 존재 : 배열 길이

2. pop
> 파라미터 필요 없음
> 리턴값 존재 : pop이 된 마지막 원소의 값

3. shift
> 첫번째 원소를 pop
> 리턴값 존재 : pop이 된 첫번째 원소의 값

4. unshift
> 배열의 가장 맨 앞에 원소를 삽입
> 리턴값 존재 : 배열의 길이

5. splice(기준 인덱스, 삭제할 원소 개수)
> ex. iveMembers.splice(0, 3)
>기준 인덱스부터 두번째 인자로 받은 개수만큼 원소 삭제
> 리턴값 존재 : 삭제한 원소로 구성되는 배열

**mutable function**
1. concat
> 새로운 배열을 만들어서 반환
>  ex. `console.log(iveMembers.concat('코드팩토리'))`
2. slice
> splice 의 immutable 버전
> splice와 다르게 두번째 인자에 몇번 index까지 삭제한 배열을 반환받을 것인지 작성
> array.slice(start index, end index + 1)
> ex. console.log(iveMembers.slice(0, 3))// 0부터 2번 index의 원소까지 삭제된 배열 


```js
petMembers = [
    '베르가',
    '오가로스',
    '모가로스',
    '테이노스',
    '청룡',
    '얀기로'
]
console.log(petMembers);                // [ '베르가', '오가로스', '모가로스', '테이노스', '청룡', '얀기로' ]

let petMembers2 = petMembers;
console.log(petMembers2);               // [ '베르가', '오가로스', '모가로스', '테이노스', '청룡', '얀기로' ]
console.log(petMembers2 === petMembers) // true : 동일한 메모리 공간을 참조한다.

let petMembers3 = [
    ...petMembers,
]
console.log(petMembers3);               // [ '베르가', '오가로스', '모가로스', '테이노스', '청룡', '얀기로' ]
console.log(petMembers3 === petMembers); // false : 다른 메모리 공간을 참조한다. immutable programming 을 할 때 spread operator를 많이 사용함

let petMembers4 = [
    petMembers
]
console.log(petMembers4);               // [ [ '베르가', '오가로스', '모가로스', '테이노스', '청룡', '얀기로' ] ]
```